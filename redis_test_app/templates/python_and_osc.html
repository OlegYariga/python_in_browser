{% extends 'header.html' %}
<style>
</style>
<body>
    {% block content %}


    <div class="jumbotron" id="top-jumbotron">
        <p class="lead">Глава 2. Получение и визуализация данных эксперимента</p>
      <h1 class="display-4">Работаем с осциллографом на Python</h1>
      <hr class="my-4">
      <p>В настоящее время широко распространены цифровые запоминающие осциллографы, имеющие USB-интерфейс для связи с компьютером.
Учитывая широкие возможности обработки и анализа электрических сигналов с помощью этого устройства, использование такого осциллографа
может стать весьма полезным при проведении эксперимента. Обычно для
таких осциллографов имеется собственная программа-драйвер, а также
программа для тестирования возможностей удалённого управления.
Представим, что нам требуется периодически получать данные с осциллографа в процессе проведения автоматизированного эксперимента. В
таком случае от нас требуется реализовать приём и передачу команд и
данных между управляющей программной на Python и осциллографом.
В качестве объекта интереса был взят двухканальный осциллограф
Rigol DS1102E, для которого можно использовать программную прослойку от компании National Instruments, именуемую NI-VISA. Интерфейс VISA (Virtual Instrument Software Architecture) представляет собой
хорошо зарекомендовавший себя стандарт для осуществления коммуникации с различными устройствами на различных платформах, в том
числе подключаемых через USB-порт. В отличие от интерфейса DAQ,
взаимодействие через интерфейс VISA очень напоминает работу через
последовательный порт: передача команды от компьютера – приём ответа от устройства. Поскольку выбранный нами осциллограф удовлетворяет протоколу USBTMC (Test and Measurement Class), он идентифицируется как «USB Test and measurement device (IVI)» и с ним можно работать через интерфейс VISA. Напомним, что вплоть до настоящего
времени загрузка последних версий инсталляционного диска NI-VISA,
равно как и пакета драйверов NI-DAQ, выполнялась с официального
сайта компании National Instruments [5] свободно, требовалась лишь регистрация на сайте. При этом нет необходимости устанавливать LabView
или иные платные программные продукты от National Instruments.
Для работы с интерфейсом NI-VISA из Python также нужно будет
установить пакет pyvisa (команда pip install pyvisa в командной
строке Windows в режиме администратора). Дополнительную информацию по пакету pyvisa можно посмотреть на сайте разработчиков [9].
После этого можно писать программу, взаимодействующую с осциллографом. В примере, показанном ниже, программа подстраивает осциллограф под характеристики измеряемого сигнала и получает содержимое
экрана осциллографа.
      </p>
        <form>
<textarea id="yourcode">
import time, visa
import numpy as np
import matplotlib.pyplot as plt
rm = visa.ResourceManager()
dev = list(rm.list_resources())
scope = rm.open_resource(dev[0], timeout=20)
res = scope.query("*IDN?")
print('Установлена связь с устройством \n',res)
if res[:5]=='Rigol':
	scope.write(":AUTO")
	time.sleep(6)
	dv = float(scope.query(":CHAN1:SCAL?"))
	print('Диапазон, В/дел. :', dv)
	dt = float(scope.query(":TIM:SCAL?"))
	print('Время, с/дел. :', dt)
	data = scope.query_binary_values(":WAV:DATA? CHAN1", datatype='B')
	n = len(data)
	print('Взято данных: ', n)
	X = np.array(range(n)) * dt/50.
	data = (255 - np.array(data)) * dv/25.
	plt.plot(X, data)
	plt.show()
else:
	print('Некорректный ответ!')
</textarea>
            <div class="text-right">
                <button type="button" class="btn btn-outline-secondary"
                        onclick="runit('yourcode', 'output', 'mycanvas')">Выполнить
                </button>
            </div>
        </form>
        <pre id="output" ></pre> <div id="mycanvas"></div>





<p>В первую очередь нам необходимо выбрать нужное устройство с
VISA-интерфейсом (строки 5-7), ибо таких устройств может быть подключено к компьютеру несколько. Структура dev содержит список всех
подключённых VISA-совместимых устройств. В нашем случае это
устройство было единственным, поэтому в строке 7 инициируем работу
с ним, выбирая первый элемент списка.
42
Основными методами pyvisa являются read (чтение информации из
прибора), write (запись информации в прибор) и query (запись команды
и, сразу затем, чтение возвращаемого результата). По умолчанию вводвывод осуществляется в символьном представлении. Первой командой,
которую дадим осциллографу, является универсальный запрос *IDN?, в
ответ на который прибор должен «представиться». Для этого используем
метод query (строка 8). Здесь мы проводим дополнительную проверку на
то, корректно ли прибор отвечает.
В строке 11 мы пересылаем в осциллограф команду :AUTO, которая
включает автоматическую настройку каналов осциллографа для наилучшего отображения регистрируемого сигнала. Выполнение команды занимает несколько секунд, поэтому в программу введена задержка по времени (строка 12). Команда не требует ответа прибора, поэтому был использован метод write. В строках 13-16 выводим установленный
диапазон по значениям напряжения (для первого канала) и по горизонтальной развёртке.
Строки 17-18 листинга наиболее интересны. Здесь выполняется команда :WAV:DATA? CHAN1, в ответ на которую осциллограф передаёт
мгновенную копию сигнала на экране осциллографа в виде последовательности байтов. Значение каждого байта есть инвертированное значение ординаты в диапазоне от 0 до 255, а порядковый номер байта – значение по абсциссам в диапазоне от 0 до 599. Для того, чтобы перевести
эти величины в реальные значения по напряжению и по времени, необходимо их умножить на соответствующий поправочный коэффициент
(25 точек/дел. по Y – строка 22, и 50 точек/дел. по X – строка 21). Однако
следует заметить, что в данном случае главной задачей была быстрая визуализация осциллограммы; если требуется получить от осциллографа
точное значение величины сигнала в какой-либо точке, следует использовать другие команды.
Поскольку по умолчанию метод query работает с символьными данными, весьма ожидаемыми являются проблемы при передаче битового
массива. Именно поэтому мы использовали метод query_binary_values.
На самом деле можно было бы взять строку символов с помощью стандартного запроса query, а затем конвертировать их в битовый массив. Однако в программе, с учётом нюансов работы с символьными значениями,
это бы выглядело более сложно:

</p>
               <form>
<textarea id="yourcode2">
scope._encoding = 'latin1'
rawdata = scope.query(":WAV:DATA? CHAN1")[10:]
data = bytearray(rawdata,'latin1')
data = np.invert(np.array(data))

</textarea>
            <div class="text-right">
                <button type="button" class="btn btn-outline-secondary"
                        onclick="runit('yourcode2', 'output2', 'mycanvas2')">Выполнить
                </button>
            </div>
        </form>
        <pre id="output2" ></pre> <div id="mycanvas2"></div>




        <p>
            Первые десять символов, приходящих с осциллографа – идентификатор формата, поэтому в данном случае мы их пропускаем. Как можно заметить, в обоих случаях очень удобно использовать numpy-массивы.
Массив по оси абсцисс достаточно просто формируется в строке 21: последовательность значений, соответствующих числу элементов в массиве data, каждый из которых умножен на поправочный коэффициент. В
строке 22 массив data инвертируется (особенность осциллографа) и
также нормируется на реальное значение по напряжению. Текстовый вывод программы приведён ниже, а результат представлен на рис. 16
        </p>




        <div class="text-right"><button class="btn btn-outline-secondary" type="button" onclick="location.href='/comments/'">Следующая тема</button></div>

    </div>


    {% endblock %}
</body>